<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="generator" content="pandoc" />
<meta name="author" content="Zhiming Wang" />
<meta name="date" content="2015-05-05T22:03:39-07:00" />
<title>Graceful handling of SIGINT when using Python's multiprocessing.Process</title>
<link rel="apple-touch-icon-precomposed" href="/img/favicon-152.png">
<meta name="msapplication-TileColor" content="#FFFFFF">
<meta name="msapplication-TileImage" content="/img/favicon-144.png">
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
</style>
<link href='/css/normalize.css' media="all" rel="stylesheet" type="text/css">
<link href='/css/theme.css' media="all" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-53908325-1', 'auto');
ga('require', 'displayfeatures');
ga('send', 'pageview');
</script>
</head>
<body>
<nav>
<div style="height:150px; width:100px; text-align:center;">
<a href="/"><img src="/img/icon-100.png" height="100" width="100" style="padding: 2px 0;"></a>
<div style="padding: 1px 0;"><a href="/"><strong>dl? cmplnts?</strong></a></div>
<div style="font-size: 9pt;">by <a href="https://github.com/zmwangx" target="_blank">Zhiming Wang</a></div>
</div>
</nav>
<article>
<header>
<h1 class="title">Graceful handling of <code>SIGINT</code> when using Python's <code>multiprocessing.Process</code></h1>
<h2 class="meta">
<time class="timestamp" datetime="2015-05-05T22:03:39-07:00">May 5, 2015,</time>
by <span class="author">Zhiming Wang</span>
</h2>
</header>
<p>Today I learned something about Python's (at least CPython's) multiprocessing and signal handling, and I would like to share it here. Basically my situation was such (when developing <a href="https://github.com/zmwangx/zmwangx.github.io/blob/source/pyblog"><code>pydoc</code></a> that powers this blog):</p>
<ul>
<li>I would like to serve the blog with an HTTP server while auto-regenerating for changes;</li>
<li>The auto-regeneration is handled in the main process with a while loop, whereas the HTTP server (requiring little human intervention) is put in a <code>multiprocessing.Process</code> and launched with <code>http.server.HTTPServer.serve_forever()</code>;</li>
<li>Upon sending <code>SIGINT</code>, both processes need to clean up and quit; in particular, the server needs to exit its <code>serve_forever()</code> loop (which can be done via <code>shutdown()</code>, but how to invoke the method is a problem, since <code>serve_forever()</code> blocks);</li>
<li>Handling of <code>SIGINT</code> must be graceful in the main process — there might be an ongoing build that must not be interrupted until finishing.</li>
</ul>
<p>Given this context, I learned the following two critical concepts (at least true in the current version of CPython) through trial and error:</p>
<ol style="list-style-type: decimal">
<li><strong>A user-triggered <code>SIGINT</code> is sent to both processes</strong> — the main process and the <code>multiprocessing.Process</code> instance;</li>
<li><strong>Except for the defined interfaces, a <code>multiprocessing.Process</code> instance is almost completely separated from the main process, sharing as little resources as possible</strong>; by &quot;defined interfaces&quot; I mean the defined attributes and methods of a <code>Process</code> instance, as well as defined communication channels like <code>multiprocessing.Pipe</code> or <code>multiprocessing.Queue</code>. And to expand on resource sharing: yes, the two processes have their own copies of global variables, so using global variables as state registers is a no-go.</li>
</ol>
<p>Both concepts can be used to one's benefit or detriment. Below is how I solved my problem, using the two concepts. Observe that without a custom handler, Python translates a <code>SIGINT</code> to a <code>KeyboardInterrupt</code> exception; therefore, I use the default <code>KeyboardInterrupt</code> to interrupt the HTTP server in its own process (through handling the exception and calling <code>shutdown()</code>), but instead install a custom <code>SIGINT</code> handler in the main process that translates <code>SIGINT</code> to setting a <code>sigint_raised</code> flag that can be picked up by the while loop once the current build (if any) is finished. The proof of concept script is as follows (the production code is <a href="https://github.com/zmwangx/zmwangx.github.io/blob/a7a0b2073f30b1d0214c3152998d95e40a39b438/pyblog#L567-L635">here</a>):</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python3</span>

<span class="ch">import</span> http.server
<span class="ch">import</span> multiprocessing
<span class="ch">import</span> signal
<span class="ch">import</span> sys
<span class="ch">import</span> time

<span class="kw">class</span> HTTPServerProcess(multiprocessing.Process):
    <span class="kw">def</span> run(<span class="ot">self</span>):
        httpd = http.server.HTTPServer(
            (<span class="st">&quot;&quot;</span>, <span class="dv">8000</span>), http.server.SimpleHTTPRequestHandler)
        <span class="kw">try</span>:
            httpd.serve_forever()
        <span class="kw">except</span> <span class="ot">KeyboardInterrupt</span>:
            httpd.shutdown()

<span class="kw">def</span> do_things():
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">10</span>):
        sys.stderr.write(<span class="st">&quot;.&quot;</span>)
        sys.stderr.flush()
        time.sleep(<span class="dv">1</span>)
    sys.stderr.write(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)

<span class="kw">def</span> main():
    server_process = HTTPServerProcess()
    server_process.start()

    <span class="co"># define and install custom SIGINT handler</span>
    sigint_raised = <span class="ot">False</span>

    <span class="kw">def</span> sigint_mitigator(signum, frame):
        <span class="kw">nonlocal</span> sigint_raised
        sigint_raised = <span class="ot">True</span>

    signal.signal(signal.SIGINT, sigint_mitigator)

    <span class="kw">while</span> not sigint_raised:
        do_things()

    server_process.join()

<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&quot;__main__&quot;</span>:
    main()</code></pre></div>
<p>Beware that with this solution, if there are external programs or OS level operations happening in the main process, then the operation at the time of <code>SIGINT</code> will still be interrupted<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> (for example, in the script above, the <code>time.sleep(1)</code> at the exact point of <code>SIGINT</code> is still interrupted, but otherwise <code>do_things</code> is carried on to its completion). I'm not sure how to explain this — maybe the handler isn't capturing the signal fast enough?<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> Anyway, one single early interruption is at least more acceptable than a completely corrupted build<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>, and certainly more graceful.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="https://hg.python.org/cpython/file/1320ec1b24af/Modules/_multiprocessing">CPython's <code>multiprocessing</code> is written in C</a>, so the behavior might depend on the OS. I'm talking about OS X here. I haven't inspected and won't inspect the C source code.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>That's awfully naive and layman-sounding, I know, but I <em>am</em> almost a layman when it comes to system-level programming.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>That's assuming your build isn't interdependent in which any single failure corrupts everything. In that case, what can we do? I honestly see no way of injecting signal handling in <code>subprocess.Popen</code>.<a href="#fnref3">↩</a></p></li>
</ol>
</div>
<footer>
<hr>
<a class="feed-icon" href="/atom.xml" target="_blank" title="Atom feed">
<a class="cc-icon" href="https://creativecommons.org/licenses/by/4.0/" target="_blank" title="Released under the Creative Commons Attribution 4.0 International license.">
<a href="https://github.com/zmwangx" target="_blank">Zhiming Wang</a>
</footer>
</article>
</body>
</html>
